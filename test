fastapi==0.83.0
starlette==0.19.1
uvicorn==0.16.0
pydantic==1.8.2



FROM python:3.6.8-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt

COPY app /app/app

EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]



services:
  api:
    build:
      context: .
    ports:
      - "8000:8000"
    environment:
      - PYTHONUNBUFFERED=1
      - DATA_DIR=/data
    volumes:
      - storageapp_data:/data

volumes:
  storageapp_data:













from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import os
import json
import datetime as dt

app = FastAPI(title="Storage Ingest API (name/used only)")

DATA_DIR = os.environ.get("DATA_DIR", "/data")
RUNS_FILE = os.path.join(DATA_DIR, "runs.jsonl")


class Metric(BaseModel):
    name: str
    used: float


class IngestPayload(BaseModel):
    run_id: str
    collected_at: str
    metrics: List[Metric]
    notes: Optional[str] = None


def _ensure_data_dir():
    if not os.path.isdir(DATA_DIR):
        os.makedirs(DATA_DIR)


@app.get("/health")
def health():
    return {"ok": True, "time_utc": dt.datetime.utcnow().isoformat() + "Z"}


@app.post("/ingest")
def ingest(payload: IngestPayload):
    _ensure_data_dir()

    record = payload.dict()
    record["_received_at"] = dt.datetime.utcnow().isoformat() + "Z"

    # run_id 중복 방지(간단 스캔) - 하루 2회 수준이면 충분
    if os.path.exists(RUNS_FILE):
        with open(RUNS_FILE, "r") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                obj = json.loads(line)
                if obj.get("run_id") == payload.run_id:
                    raise HTTPException(status_code=409, detail="run_id already exists")

    with open(RUNS_FILE, "a") as f:
        f.write(json.dumps(record) + "\n")

    return {"accepted": True, "run_id": payload.run_id, "count": len(payload.metrics)}


@app.get("/runs/latest")
def latest():
    if not os.path.exists(RUNS_FILE):
        raise HTTPException(status_code=404, detail="no runs yet")

    last = None
    with open(RUNS_FILE, "r") as f:
        for line in f:
            line = line.strip()
            if line:
                last = line

    if not last:
        raise HTTPException(status_code=404, detail="no runs yet")

    return json.loads(last)
